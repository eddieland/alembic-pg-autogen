"""Integration tests for the full autogenerate pipeline."""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING

import pytest
from alembic.command import revision

if TYPE_CHECKING:
    from .alembic_helpers import AlembicProject


def _autogenerate(project: AlembicProject, **attrs: object) -> str:
    """Run autogenerate and return the generated migration file content."""
    cfg = project.config
    cfg.attributes["search_path"] = project.schema
    for key, value in attrs.items():
        cfg.attributes[key] = value

    script = revision(cfg, message="test", autogenerate=True)
    assert script is not None

    versions_dir = Path(cfg.get_main_option("script_location")) / "versions"  # pyright: ignore[reportArgumentType]
    migration_files = list(versions_dir.glob("*.py"))
    assert len(migration_files) == 1
    return migration_files[0].read_text()


@pytest.mark.integration
class TestAutogenerateCreateFunction:
    """5.1 — Autogenerate detects new functions."""

    def test_new_function_produces_create(self, alembic_project: AlembicProject):
        fn_ddl = f"""\
CREATE OR REPLACE FUNCTION {alembic_project.schema}.hello()
RETURNS text LANGUAGE sql AS $$ SELECT 'hi'::text $$"""

        content = _autogenerate(alembic_project, pg_functions=[fn_ddl])

        assert "op.execute(" in content
        assert "CREATE OR REPLACE FUNCTION" in content
        assert "hello" in content


@pytest.mark.integration
class TestAutogenerateReplaceFunction:
    """5.2 — Autogenerate detects modified functions."""

    def test_modified_function_produces_replace(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"""\
            CREATE FUNCTION {schema}.greet() RETURNS text
            LANGUAGE sql AS $$ SELECT 'hello'::text $$
        """)

        new_ddl = f"""\
CREATE OR REPLACE FUNCTION {schema}.greet()
RETURNS text LANGUAGE sql AS $$ SELECT 'goodbye'::text $$"""

        content = _autogenerate(alembic_project, pg_functions=[new_ddl])

        assert "op.execute(" in content
        assert "goodbye" in content
        # Downgrade should contain the original definition
        assert "hello" in content or "DROP FUNCTION" in content


@pytest.mark.integration
class TestAutogenerateDropFunction:
    """5.3 — Autogenerate detects removed functions."""

    def test_dropped_function_produces_drop(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"""\
            CREATE FUNCTION {schema}.obsolete() RETURNS void
            LANGUAGE sql AS $$ $$
        """)

        # Empty desired set with pg_functions=[] triggers the comparator but
        # declares no desired functions — existing ones should be dropped.
        content = _autogenerate(alembic_project, pg_functions=[])

        assert "DROP FUNCTION" in content
        assert "obsolete" in content


@pytest.mark.integration
class TestAutogenerateTriggers:
    """5.4 — Autogenerate detects trigger changes."""

    def test_new_trigger_produces_create(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"CREATE TABLE {schema}.events (id int)")
        alembic_project.execute(f"""\
            CREATE FUNCTION {schema}.trg_fn() RETURNS trigger
            LANGUAGE plpgsql AS $$ BEGIN RETURN NEW; END $$
        """)

        fn_ddl = f"""\
CREATE OR REPLACE FUNCTION {schema}.trg_fn() RETURNS trigger
LANGUAGE plpgsql AS $$ BEGIN RETURN NEW; END $$"""
        trg_ddl = f"""\
CREATE TRIGGER notify_trg AFTER INSERT ON {schema}.events
FOR EACH ROW EXECUTE FUNCTION {schema}.trg_fn()"""

        content = _autogenerate(
            alembic_project,
            pg_functions=[fn_ddl],
            pg_triggers=[trg_ddl],
        )

        assert "CREATE TRIGGER" in content
        assert "notify_trg" in content

    def test_dropped_trigger_produces_drop(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"CREATE TABLE {schema}.events (id int)")
        alembic_project.execute(f"""\
            CREATE FUNCTION {schema}.trg_fn() RETURNS trigger
            LANGUAGE plpgsql AS $$ BEGIN RETURN NEW; END $$
        """)
        alembic_project.execute(f"""\
            CREATE TRIGGER old_trg AFTER INSERT ON {schema}.events
            FOR EACH ROW EXECUTE FUNCTION {schema}.trg_fn()
        """)

        # Declare the function but NOT the trigger → trigger should be dropped
        fn_ddl = f"""\
CREATE OR REPLACE FUNCTION {schema}.trg_fn() RETURNS trigger
LANGUAGE plpgsql AS $$ BEGIN RETURN NEW; END $$"""

        content = _autogenerate(
            alembic_project,
            pg_functions=[fn_ddl],
            pg_triggers=[],
        )

        assert "DROP TRIGGER" in content
        assert "old_trg" in content


@pytest.mark.integration
class TestAutogenerateDependencyOrdering:
    """5.5 — Operations appear in correct dependency order."""

    def test_function_creates_before_trigger_creates(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"CREATE TABLE {schema}.orders (id int)")

        fn_ddl = f"""\
CREATE OR REPLACE FUNCTION {schema}.audit_fn() RETURNS trigger
LANGUAGE plpgsql AS $$ BEGIN RETURN NEW; END $$"""
        trg_ddl = f"""\
CREATE TRIGGER audit_trg AFTER INSERT ON {schema}.orders
FOR EACH ROW EXECUTE FUNCTION {schema}.audit_fn()"""

        content = _autogenerate(
            alembic_project,
            pg_functions=[fn_ddl],
            pg_triggers=[trg_ddl],
        )

        # In upgrade(), function CREATE should appear before trigger CREATE
        upgrade_match = re.search(r"def upgrade\(\).*?(?=def downgrade\(\))", content, re.DOTALL)
        assert upgrade_match is not None
        upgrade_body = upgrade_match.group(0)

        fn_pos = upgrade_body.find("audit_fn")
        trg_pos = upgrade_body.find("audit_trg")
        assert fn_pos != -1 and trg_pos != -1
        assert fn_pos < trg_pos, "Function CREATE should precede trigger CREATE in upgrade"


@pytest.mark.integration
class TestAutogenerateNoOp:
    """5.6 — No ops when state matches."""

    def test_matching_state_produces_no_ops(self, alembic_project: AlembicProject):
        schema = alembic_project.schema
        alembic_project.execute(f"""\
            CREATE FUNCTION {schema}.stable_fn() RETURNS void
            LANGUAGE sql AS $$ $$
        """)

        fn_ddl = f"""\
CREATE OR REPLACE FUNCTION {schema}.stable_fn() RETURNS void
LANGUAGE sql AS $$ $$"""

        content = _autogenerate(alembic_project, pg_functions=[fn_ddl])

        # upgrade() should just have "pass" — no ops
        upgrade_match = re.search(r"def upgrade\(\).*?(?=def downgrade\(\))", content, re.DOTALL)
        assert upgrade_match is not None
        assert "op.execute(" not in upgrade_match.group(0)


@pytest.mark.integration
class TestAutogenerateEmptyConfig:
    """5.7 — No errors when pg_functions/pg_triggers absent."""

    def test_no_config_produces_no_ops(self, alembic_project: AlembicProject):
        # Don't pass pg_functions or pg_triggers at all
        content = _autogenerate(alembic_project)

        # Should produce a valid migration with pass in upgrade/downgrade
        assert "def upgrade()" in content
        assert "def downgrade()" in content
